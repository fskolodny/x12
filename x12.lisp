;;;; x12.lisp

(in-package #:x12)
(named-readtables:in-readtable rutils-readtable)

;;; "X12" goes here. Hacks and glory await!
(defvar s (char-code #\^))
(defvar r (char-code #\~))
(defvar f (char-code #\*))
(defvar whitespace (coerce #v((char-code #\space) (char-code #\return)
                      (char-code #\newline) (char-code #\tab)
                      ) 'list))
(defclass record ()
  (
   (record-type :accessor record-type :initarg :type :allocation :class)
   (fields :accessor fields)
   )
  )
(defclass bracket (record)
  (
   (parent :accessor parent)
   )
  )
(defclass header (bracket)
  (
    )
  )
(defclass trailer (bracket)
  (
   )
  )
(defmethod initialize-instance ((self record) &rest initargs
                                &key f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13
                                  f14 f15 f16 f17 f18 f19 f20)
  (call-next-method)
  (let ((field-count (if f20 20 (if f19 19 (if f18 18 (if f17 17 (if f16 16 (if f15 15 (if f14 14 (if f13 13 (if f12 12 (if f11 11 (if f10 10 (if f9 9 (if f8 8 (if f7 7 (if f6 6 (if f5 5 (if f4 4 (if f3 3 (if f2 2 (if f1 1 (error "No fields specified for record type ~a" (record-type self)))))))))))))))))))))))
        (al (plist-to-alist initargs))
        )
    (format t "~a" al)
    (setf (fields self)
          (make-array field-count :element-type '(or string octet null)
                      :initial-element nil))
    (iter
      (:for i :from 1 :to 30)
      (let ((sym (assoc (ensure-keyword i :format "F~d") al))
            )
        (if sym
            (setf (aref (fields self) (1- i))
                  (sb-ext:octets-to-string (cdr sym))))
        )
      )
    )
  )
(defclass isa (header)
  ((record-type :initform "ISA"))
  )
(defclass iea (trailer)
  ((record-type :initform "IEA"))
  )
(defclass gs (header)
  ((record-type :initform "GS"))
  )
(defclass ge (trailer)
  ((record-type :initform "GE"))
  )
(defclass st (header)
  (
   (record-type :initform "ST")
   (transmittal-type :allocation :class)
   )
  )
(defclass _270 (st)
  (
   (transmittal-type :initform "270")
   )
  )
(defclass paired ()
  (
   (children :accessor children :initarg :children :initform nil)
   (transmittal-id :accessor transmittal-id :initform "")
   (transmittal-id-position :accessor transmittal-id-position
                            :allocation :class)
   (header :accessor header :initarg :header :type 'header)
   (trailer :accessor trailer :initarg :trailer :type 'trailer)
   )
  )
(defmethod initialize-instance ((self paired) &key)
  (setf (parent header) self (parent trailer) self)
  )
(defclass st/se (paired)
  (
   (transmittal-id-position :initform 2)
   )
  )
(defclass gs/ge (paired)
  (
   (transmittal-id-position :initform 6)
   )
  )
(defclass isa/iea (paired)
  (
   (record-delimiter :accessor record-delimiter :initarg :record-delimiter :initform #\~)
   (field-delimiter :accessor field-delimiter :initarg :field-delimiter :initform #\*)
   (subfield-delimiter :accessor subfield-delimiter :initarg :subfield-delimiter :initform #\^)
   (test-or-prod :accessor test-or-prod :initarg :test-or-prod :initform #\P)
   (date)
   (time)
   (transmittal-id-position :initform 13)
   )
  )
(defgeneric child-count (object)
  )
(defmethod child-count ((self paired))
  (length (children self))
  )
(defmethod child-count ((self st/se))
  (+ 2 (length (children self)))
  )
(defmethod print-object ((self paired) stream)
  (with-slots (header children self) self
    (format stream "~a~{~a~}~a" header children trailer)
    )
  )
(defmethod print-object ((self trailer) stream)
  (let ((f (code-char f))
        (r (code-char r))
        )
    (with-slots (record-type transmittal-id) self
      (format stream "~a~c~d~c~a~c" record-type f (child-count self) f
              transmittal-id r)
      )
    )
  )
(defmethod print-object ((self isa/iea) stream)
  (multiple-value-bind (second minute hour day month year dow dst tz)
      (get-decoded-time)
    (declare (ignorable second dow dst tz))
    (let (
          (s (slot-value self 'subfield-delimiter))
          (f (slot-value self 'field-delimiter))
          (r (slot-value self 'record-delimiter))
          )
      (setf (transmittal-id self)
            (format nil "~d~2,'0d~2,'0d~2,'0d~2,'0d" (mod year 10) month day
                    hour minute)
            (slot-value self 'date)
            (format nil "~4,'0d~2,'0d~2,'0d" year month day)
            (slot-value self 'time) (format nil "~2,'0d~2,'0d" hour minute)
            )
      (call-next-method)
      )
    )
  )
(defun coerce-to-char (c) (if (typep c 'character) c (code-char c)))
(defmethod print-object ((self record) stream)
   (format stream (fmt "~~a~~{~c~~a~~}~~c"
                       (coerce-to-char f))
           (record-type self) (coerce (fields self) 'list) (coerce-to-char r))
  )
(defmethod print-object ((self isa) stream)
  (with-slots (record-type date time test-or-prod) self
      (format stream
              "~a~c00~c~14@a00~11a~cZZ~c~15a~cZZ~c~15a~c~a~c~a~c~c~c~a~c0~c~c~c~c~c"
              record-type f f f f f f "16489767" f f "EMDEON" f
              (subseq date 2) f time f s f transmittal-id f f test-or-prod f
              #\< r)
      )
    )


(defun read-5010-record (stream &optional a b)
  (declare (ignorable a b))
  (let* ((c (skip-whitespace stream))
         (buf (funcall #'vector
                       (iter
                         (:for i :from 0 :to 9999)
                         (:until (= c r))
                         (:collect c)
                         (setf c (read-byte stream nil r))
                         )
                       ))
         (seq (split-sequence f buf))
         (class (find-class (intern (sb-ext:octets-to-string (elt seq 0))
                                    :x12)))
         (obj (apply #'make-instance class
                     (zip '(:f0 :f1 :f2 :f3 :f4 :f5 :f6 :f7 :f8 :f9 :f10 :f11
                            :f12 :f13 :f14 :f15 :f16 :f17 :f18 :f19 :f20 :f21
                            :f22)
                          seq)))
         )
    obj
    )
  )

(defun read-gs/ge-pair (temp-record stream)
  (let ((ge-record nil)
        )
    (iter
      (finally
       (return-from read-gs/ge-pair
           (make-instance 'gs/ge :header gs-record :trailer ge-record
                          :children children)))
      (setf temp-record (read-5010-record stream))
      (:while (not ge-record))
      (case (class-of temp-record)
        ((find-class 'st)
         (:collect (read-st/se-pair temp-record stream) :into children))
        ((find-class 'ge)
         (setf ge-record temp-record))
        )
      )
    )
  )

(defun skip-whitespace (stream)
  (let ((c)
        )
    (iter
      (:for i :from 0 :to 999999)
      (setf c (read-byte stream nil nil))
      (if (member c whitespace :test #'=)
          (next-iteration)
          (return-from skip-whitespace c))
      )
    )
  )

(defun read-isa-record (stream)
  (let ((c (skip-whitespace stream))
        (record (make-array 106 :element-type '(unsigned-byte 8)))
        (cnt)
        )
    (setf (aref record 0) c
          cnt (read-sequence record stream :start 1))
    (unless (= cnt 106)
      (format t "Only read ~d bytes from stream~&" (1- cnt))
      (error "Cannot read ISA from stream ~a, too short only read ~d bytes"
             stream cnt)
      )
    (let* (
           (r (aref record 105))
           (f (aref record 103))
           (s (aref record 82))
           (subsubfield-delimiter (aref record 104))
           (isa-record)
           (positions (coerce (iter
                                (:for i :from 0 :to 105)
                                (if (= (aref record i) f)
                                    (:collect i)))
                              'vector))
          )
      (unless (and (equalp (subseq record 0 3)
                           #v((char-code #\I) (char-code #\S) (char-code #\A)))
                   (equalp #v(3 6 17 20 31 34 50 53 69 76 81 83 89 99 101 103)
                           positions
                           )
                   )
        (format t "~a" positions)
        (error "~a record does not match specification for ISA" record))
      )
    (make-instance 'isa :f1 (subseq record 4 6) :f2 (subseq record 7 17)
                   :f3 (subseq record 18 20) :f4 (subseq record 21 31)
                   :f5 (subseq record 32 34) :f6 (subseq record 35 50)
                   :f7 (subseq record 51 53) :f8 (subseq record 54 69)
                   :f9 (subseq record 70 76) :f10 (subseq record 77 81)
                   :f11 (subseq record 82 83) :f12 (subseq record 84 89)
                   :f13 (subseq record 90 99) :f14 (subseq record 100 101)
                   :f15 (subseq record 102 103) :f16 (subseq record 104 105)
                   )
    )
  )

(defun read-isa/iea-pair (record stream)
  (declare (type stream stream))
  (let (
        (record (make-array 106 :element-type '(unsigned-byte 8)))
        (cnt)
        )
    (setf cnt (read-sequence record stream))
    (unless (= cnt 106)
      (error "Cannot read ISA from stream ~a, too short only read ~d bytes"
             stream cnt))
    (let (
          (r (aref record 105))
          (f (aref record 103))
          (s (aref record 82))
          (subsubfield-delimiter (aref record 104))
          (isa-record)
          )
      (unless (and (equalp (subseq record 0 3)
                           #v((char-code #\I) (char-code #\S) (char-code #\A)))
                   (equalp #v(3 6 17 20 31 34 50 53 69 76 81 83 89 99 101 103)
                           (coerce (iter
                                    (:for i :from 0 :to 105)
                                    (if (= (aref record i) f)
                                        (:collect i)))
                                   'vector)
                           )
                   )
        (error "~a record does not match specification for ISA" record))
      (setf isa-record 
            (make-instance 'isa :f1 (subseq record 4 6)
                           :f2 (subseq record 7 17)
                           :f3 (subseq record 18 20) :f4 (subseq record 21 31)
                           :f5 (subseq record 32 34) :f6 (subseq record 35 50)
                           :f7 (subseq record 51 53) :f8 (subseq record 54 69)
                           :f9 (subseq record 70 76) :f10 (subseq record 77 81)
                           :f11 (subseq record 82 83)
                           :f12 (subseq record 84 89)
                           :f13 (subseq record 90 99)
                           :f14 (subseq record 100 101)
                           :f15 (subseq record 102 103)
                           :f16 (subseq record 104 105)))
      (make-instance 'isa/iea :header isa-record :trailer iea-record
                     :children
                     (loop as temp = (read-5010-record stream)
                        as class = (class-of temp)
                        until (eql (find-class 'iea) class)
                        collect temp
                          )
                     :record-delimiter r
                     :field-delimiter f :subfield-delimiter s)
      )
    )
  )
