;;;; x12.lisp

(in-package #:x12)
(named-readtables:in-readtable rutils-readtable)

;;; "X12" goes here. Hacks and glory await!
(defvar s (char-code #\^))
(defvar r (char-code #\~))
(defvar f (char-code #\*))
(defvar whitespace (coerce #v((char-code #\space) (char-code #\return)
                      (char-code #\newline) (char-code #\tab)
                      ) 'list))
(defclass coded-value ()
  (
   (code :accessor code :initarg :code)
   (value :accessor value :initarg :value)
   )
  )
(defclass record ()
  (
   (record-type :accessor record-type :initarg :type :allocation :class)
   (fields :accessor fields)
   )
  )
(defclass bracket (record)
  (
   (parent :accessor parent)
   )
  )
(defclass header (bracket)
  (
    )
  )
(defclass trailer (bracket)
  (
   (count :accessor record-count :initarg :count)
   (control-id :accessor control-id :initarg :control-id)
   )
  )
(defmethod initialize-instance ((self trailer) &key &allow-other-keys)
  (call-next-method)
  (unless (slot-boundp self 'count)
    (setf (record-count self) (aref (fields self) 0)))
  (unless (slot-boundp self 'control-id)
    (setf (control-id self) (aref (fields self) 1))))
(defmethod initialize-instance ((self record) &rest initargs
                                &key &allow-other-keys)
  (call-next-method)
  (let* (
         (al (plist-to-alist initargs))
         (field-count (iter
                        (:for cell :in al)
                        (let* ((sym (car cell))
                               (name (symbol-name sym))
                               (num (or (and (typep sym 'keyword)
                                             (char= #\F (char name 0))
                                             (multiple-value-bind (n d)
                                                 (parse-integer name :start 1)
                                               (and (eq d (length name)) n)))
                                        0)
                                 )
                               )
                          (:maximize num)
                          )
                        )
           )
         )
    (format t "~a~%" al)
    (setf (fields self)
          (make-array field-count :element-type '(or string octet null)
                      :initial-element nil))
    (iter
      (:for i :from 1 :to field-count)
      (let ((sym (assoc (ensure-keyword i :format "F~d") al))
            )
        (if sym
            (setf (aref (fields self) (1- i))
                  (octets-to-string (cdr sym))))
        )
      )
    )
  )
(defclass bht (record)
  (
   (record-type :initform "BHT")
   )
  )
(defclass hl (record)
  (
   (record-type :initform "HL")
   )
  )
(defclass nm1 (record)
  (
   (record-type :initform "NM1")
   )
  )
(defclass per (record)
  (
   (record-type :initform "PER")
   )
  )
(defclass n3 (record)
  (
   (record-type :initform "N3")
   )
  )
(defclass n4 (record)
  (
   (record-type :initform "N4")
   )
  )
(defclass trn (record)
  (
   (record-type :initform "TRN")
   )
  )
(defclass dmg (record)
  (
   (record-type :initform "DMG")
   )
  )
(defclass dtp (record)
  (
   (record-type :initform "DTP")
   )
  )
(defclass eb (record)
  (
   (record-type :initform "EB")
   )
  )
(defclass hsd (record)
  (
   (record-type :initform "HSD")
   )
  )
(defclass msg (record)
  (
   (record-type :initform "MSG")
   )
  )
(defclass ref (record)
  (
   (record-type :initform "REF")
   )
  )
(defclass le (record)
  (
   (record-type :initform "LE")
   )
  )
(defclass ls (record)
  (
   (record-type :initform "LS")
   )
  )
(defclass isa (header)
  ((record-type :initform "ISA")
   (authorization-info :accessor authorization-info :initarg :authorization-info)
   (security-info :accessor security-info :initarg :security-info)
   (interchange-sender :accessor interchange-sender :initarg :interchange-sender)
   (interchange-receiver :accessor interchange-receiver :initarg :interchange-receiver)
   (interchange-date :accessor interchange-date :initarg :interchange-date)
   (interchange-time :accessor interchange-time :initarg :interchange-time)
   (interchange-type :accessor interchange-type :initarg :interchange-type)
   (control-id :accessor control-id :initarg :control-id)
   (ack-needed :accessor ack-needed :initarg :ack-needed)
   (usage-indicator :accessor usage-indicator :initarg :usage-indicator)
   )
  )
(defmethod initialize-instance ((self isa) &key interchange-type ack-needed usage-indicator
                                             &allow-other-keys)
  (unless (member interchange-type (list (string-to-octets "00501")) :test 'equalp)
    (error "Invalid interchange type ~a" interchange-type))
  (unless (member ack-needed (list (string-to-octets "0") (string-to-octets "1")) :test 'equalp)
    (error "Invalid acknowledgement-needed ~a must be 0 or 1" ack-needed))
  (unless (member usage-indicator (list (string-to-octets "T")
                                        (string-to-octets "P")) :test 'equalp)
    (error "Invalid usage indicator ~a must be \"T\" or \"P\"" usage-indicator))
  (call-next-method)
  )
(defclass iea (trailer)
  ((record-type :initform "IEA"))
  )
(defclass gs (header)
  ((record-type :initform "GS")
   )
  )
(defclass ge (trailer)
  ((record-type :initform "GE"))
  )
(defclass st (header)
  (
   (record-type :initform "ST")
   (transmittal-type :accessor transmittal-type)
   (file-standard :accessor file-standard)
   )
  )
(defclass se (trailer)
  ((record-type :initform "SE"))
  )
(defmethod initialize-instance ((self st) &key f1 f3)
  (with-slots (transmittal-type file-standard) self
    (setf transmittal-type f1 file-standard f3)
    )
  )
(defclass paired ()
  (
   (children :accessor children :initarg :children :initform nil)
   (transmittal-id :accessor transmittal-id :initform "")
   (transmittal-id-position :accessor transmittal-id-position
                            :allocation :class)
   (header :accessor header :initarg :header :type 'header)
   (trailer :accessor trailer :initarg :trailer :type 'trailer)
   )
  )
(defmethod initialize-instance ((self paired) &key)
  (call-next-method)
  (with-slots (header trailer) self
    (if header (setf (parent header) self))
    (if trailer (setf (parent trailer) self))
    )
  )
(defclass st/se (paired)
  (
   (transmittal-id-position :initform 2)
   )
  )
(defclass gs/ge (paired)
  (
   (transmittal-id-position :initform 6)
   )
  )
(defclass isa/iea (paired)
  (
   (record-delimiter :accessor record-delimiter :initarg :record-delimiter :initform #\~)
   (field-delimiter :accessor field-delimiter :initarg :field-delimiter :initform #\*)
   (subfield-delimiter :accessor subfield-delimiter :initarg :subfield-delimiter :initform #\^)
   (test-or-prod :accessor test-or-prod :initarg :test-or-prod :initform #\P)
   (date)
   (time)
   (transmittal-id-position :initform 13)
   )
  )
(defgeneric child-count (object)
  )
(defmethod child-count ((self paired))
  (length (children self))
  )
(defmethod child-count ((self st/se))
  (+ 2 (length (children self)))
  )
(defmethod print-object ((self paired) stream)
  (with-slots (header children trailer) self
    (format stream "~a~{~a~}~a" header children trailer)
    )
  )
(defmethod print-object ((self trailer) stream)
  (let ((f (coerce-to-char f))
        (r (coerce-to-char r))
        )
    (with-slots (record-type control-id parent) self
      (format stream "~a~c~d~c~a~c" record-type f (child-count parent) f
              control-id r)
      )
    )
  )
(defmethod print-object ((self isa/iea) stream)
  (multiple-value-bind (second minute hour day month year dow dst tz)
      (get-decoded-time)
    (declare (ignorable second dow dst tz))
    (let (
          (s (slot-value self 'subfield-delimiter))
          (f (slot-value self 'field-delimiter))
          (r (slot-value self 'record-delimiter))
          )
      (setf (transmittal-id self)
            (format nil "~d~2,'0d~2,'0d~2,'0d~2,'0d" (mod year 10) month day
                    hour minute)
            (slot-value self 'date)
            (format nil "~4,'0d~2,'0d~2,'0d" year month day)
            (slot-value self 'time) (format nil "~2,'0d~2,'0d" hour minute)
            )
      (call-next-method)
      )
    )
  )
(defun coerce-to-char (c) (if (typep c 'character) c (code-char c)))
(defmethod print-object ((self record) stream)
   (format stream (fmt "~~a~~{~c~~a~~}~~c"
                       (coerce-to-char f))
           (record-type self) (coerce (fields self) 'list) (coerce-to-char r))
  )
(defmethod print-object ((self isa) stream)
  (let ((f (coerce-to-char f))
        (s (coerce-to-char s))
        (r (coerce-to-char r))
        )
    (with-slots (record-type parent usage-indicator) self
      (with-slots (date time transmittal-id) parent
        (format stream
                "~a~c00~c~14@a00~11a~cZZ~c~15a~cZZ~c~15a~c~a~c~a~c~c~c~a~c0~c~c~c~c~c"
                record-type f f f f f f "16489767" f f "EMDEON" f
                (subseq date 2) f time f s f transmittal-id f f
                (char (octets-to-string usage-indicator) 0) f #\< r)
        )
      )
    )
  )


(defun read-5010-record (stream &optional a b)
  (declare (type stream stream)
           (ignorable a b)
           )
  (let* ((c (skip-whitespace stream))
         (buf (coerce (iter
                        (:for i :from 0 :to 9999)
                        (:until (= c r))
                        (:collect c)
                        (setf c (read-byte stream nil r))
                        )
                      'vector))
         (seq (split-sequence f buf))
         (class-name (octets-to-string (elt seq 0)))
         (class (or (find-class (intern class-name :x12))
                    (error "Class ~a not found." class-name)))
         (obj (apply #'make-instance class
                     (flatten (zip (iter
                                    (:for i :from 0 :to (length seq))
                                    (:collect (ensure-keyword i :format "F~d"))
                                    )
                                   seq
                                   )
                              )
                     )
           )
         )
    obj
    )
  )
(defun read-st/se-pair (temp-record stream)
  (declare (type stream stream))
  (let ((se-record nil)
        (st-record temp-record)
        )
    (iter
      (setf temp-record (read-5010-record stream))
      (:while (not se-record))
      (if (typep temp-record 'se)
          (progn
            (setf se-record temp-record)
            (return-from read-st/se-pair
                 (make-instance 'st/se :header st-record :trailer se-record
                                :children children))
            )
          (:collect temp-record :into children))
      )
    )
  )
(defun read-gs/ge-pair (temp-record stream)
  (declare (type stream stream))
  (let ((ge-record nil)
        (gs-record temp-record)
        )
    (iter
      (setf temp-record (read-5010-record stream))
      (:while (not ge-record))
      (if (typep temp-record 'st)
          (:collect (read-st/se-pair temp-record stream) :into children)
          (if (typep temp-record 'ge)
              (progn
                (setf ge-record temp-record)
                (return-from read-gs/ge-pair
                  (make-instance 'gs/ge :header gs-record :trailer ge-record
                                 :children children))
                )
              (error "Invalid class ~a found." (class-of temp-record)))
          )
      )
    )
  )

(defun skip-whitespace (stream)
  (declare (type stream stream))
  (let ((c)
        )
    (iter
      (:for i :from 0 :to 999999)
      (setf c (read-byte stream nil r))
      (if (not (member c whitespace :test #'=))
          (return-from skip-whitespace c))
      )
    )
  )

(defun read-isa-record (stream)
  (declare (type stream stream))
  (let ((c (skip-whitespace stream))
        (record (make-array 106 :element-type '(unsigned-byte 8)))
        (cnt)
        )
    (setf (aref record 0) c
          cnt (read-sequence record stream :start 1))
    (unless (= cnt 106)
      (format t "Only read ~d bytes from stream~%" (1- cnt))
      (error "Cannot read ISA from stream ~a, too short only read ~d bytes"
             stream cnt)
      )
      record
    )
  )

(defmacro make-coded-value (code value)
  `(make-instance 'coded-value :code ,code :value ,value)
  )
(defun read-isa/iea-pair (stream)
  (declare (type stream stream))
  (let* (
         (record (read-isa-record stream))
         (r (aref record 105))
         (f (aref record 3))
         (s (aref record 82))
         (subsubfield-delimiter (aref record 104))
         (isa-record)
         (iea-record nil)
         (temp-record)
         (children)
         )
    (unless (and (equalp (subseq record 0 3)
                         #v((char-code #\I) (char-code #\S) (char-code #\A)))
                 (equalp #v(3 6 17 20 31 34 50 53 69 76 81 83 89 99 101 103)
                         (coerce (iter
                                   (:for i :from 0 :to 105)
                                   (if (= (aref record i) f)
                                       (:collect i)))
                                 'vector)
                         )
                 )
      (error "~a record does not match specification for ISA" record))
    (setf isa-record 
          (make-instance 'isa
                         :authorization-info
                         (make-coded-value (subseq record 4 6)
                                           (subseq record 7 17))
                         :security-info
                         (make-coded-value (subseq record 18 20)
                                           (subseq record 21 31))
                         :interchange-sender
                         (make-coded-value (subseq record 32 34)
                                           (subseq record 35 50))
                         :interchange-receiver
                         (make-coded-value (subseq record 51 53)
                                           (subseq record 54 69))
                         :interchange-date (subseq record 70 76)
                         :interchange-time (subseq record 77 81)
                         :interchange-type (subseq record 84 89)
                         :control-id (subseq record 90 99)
                         :ack-needed (subseq record 100 101)
                         :usage-indicator (subseq record 102 103)))
    (setf children
          (iter
            (setf temp-record (read-5010-record stream))
            (:while (not iea-record))
            (if (typep temp-record 'gs)
                (:collect (read-gs/ge-pair temp-record stream) :into kids)
                (if (typep temp-record 'iea)
                    (progn
                      (setf iea-record temp-record)
                      (return kids)
                      )
                    (error "Bad class ~a." (class-of temp-record))
                    )
                )
            )
          )
    (make-instance 'isa/iea :header isa-record :trailer iea-record
                   :children children
                   :record-delimiter r
                   :field-delimiter f :subfield-delimiter s)
    )
  )

